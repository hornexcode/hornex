// Code generated by counterfeiter. DO NOT EDIT.
package restfakes

import (
	"context"
	"sync"

	"hornex.gg/hx-core/internal"
	"hornex.gg/hx-core/internal/rest"
)

type FakeUserService struct {
	ConfirmSignUpStub        func(context.Context, string, string) error
	confirmSignUpMutex       sync.RWMutex
	confirmSignUpArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 string
	}
	confirmSignUpReturns struct {
		result1 error
	}
	confirmSignUpReturnsOnCall map[int]struct {
		result1 error
	}
	GetEmailConfirmationCodeStub        func(context.Context, string) error
	getEmailConfirmationCodeMutex       sync.RWMutex
	getEmailConfirmationCodeArgsForCall []struct {
		arg1 context.Context
		arg2 string
	}
	getEmailConfirmationCodeReturns struct {
		result1 error
	}
	getEmailConfirmationCodeReturnsOnCall map[int]struct {
		result1 error
	}
	GetUserByIdStub        func(context.Context, string) (internal.User, error)
	getUserByIdMutex       sync.RWMutex
	getUserByIdArgsForCall []struct {
		arg1 context.Context
		arg2 string
	}
	getUserByIdReturns struct {
		result1 internal.User
		result2 error
	}
	getUserByIdReturnsOnCall map[int]struct {
		result1 internal.User
		result2 error
	}
	LoginStub        func(context.Context, string, string) (string, error)
	loginMutex       sync.RWMutex
	loginArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 string
	}
	loginReturns struct {
		result1 string
		result2 error
	}
	loginReturnsOnCall map[int]struct {
		result1 string
		result2 error
	}
	SearchStub        func(context.Context, string) (*internal.User, error)
	searchMutex       sync.RWMutex
	searchArgsForCall []struct {
		arg1 context.Context
		arg2 string
	}
	searchReturns struct {
		result1 *internal.User
		result2 error
	}
	searchReturnsOnCall map[int]struct {
		result1 *internal.User
		result2 error
	}
	SignUpStub        func(context.Context, internal.UserCreateParams) (internal.User, string, error)
	signUpMutex       sync.RWMutex
	signUpArgsForCall []struct {
		arg1 context.Context
		arg2 internal.UserCreateParams
	}
	signUpReturns struct {
		result1 internal.User
		result2 string
		result3 error
	}
	signUpReturnsOnCall map[int]struct {
		result1 internal.User
		result2 string
		result3 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeUserService) ConfirmSignUp(arg1 context.Context, arg2 string, arg3 string) error {
	fake.confirmSignUpMutex.Lock()
	ret, specificReturn := fake.confirmSignUpReturnsOnCall[len(fake.confirmSignUpArgsForCall)]
	fake.confirmSignUpArgsForCall = append(fake.confirmSignUpArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 string
	}{arg1, arg2, arg3})
	stub := fake.ConfirmSignUpStub
	fakeReturns := fake.confirmSignUpReturns
	fake.recordInvocation("ConfirmSignUp", []interface{}{arg1, arg2, arg3})
	fake.confirmSignUpMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeUserService) ConfirmSignUpCallCount() int {
	fake.confirmSignUpMutex.RLock()
	defer fake.confirmSignUpMutex.RUnlock()
	return len(fake.confirmSignUpArgsForCall)
}

func (fake *FakeUserService) ConfirmSignUpCalls(stub func(context.Context, string, string) error) {
	fake.confirmSignUpMutex.Lock()
	defer fake.confirmSignUpMutex.Unlock()
	fake.ConfirmSignUpStub = stub
}

func (fake *FakeUserService) ConfirmSignUpArgsForCall(i int) (context.Context, string, string) {
	fake.confirmSignUpMutex.RLock()
	defer fake.confirmSignUpMutex.RUnlock()
	argsForCall := fake.confirmSignUpArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeUserService) ConfirmSignUpReturns(result1 error) {
	fake.confirmSignUpMutex.Lock()
	defer fake.confirmSignUpMutex.Unlock()
	fake.ConfirmSignUpStub = nil
	fake.confirmSignUpReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeUserService) ConfirmSignUpReturnsOnCall(i int, result1 error) {
	fake.confirmSignUpMutex.Lock()
	defer fake.confirmSignUpMutex.Unlock()
	fake.ConfirmSignUpStub = nil
	if fake.confirmSignUpReturnsOnCall == nil {
		fake.confirmSignUpReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.confirmSignUpReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeUserService) GetEmailConfirmationCode(arg1 context.Context, arg2 string) error {
	fake.getEmailConfirmationCodeMutex.Lock()
	ret, specificReturn := fake.getEmailConfirmationCodeReturnsOnCall[len(fake.getEmailConfirmationCodeArgsForCall)]
	fake.getEmailConfirmationCodeArgsForCall = append(fake.getEmailConfirmationCodeArgsForCall, struct {
		arg1 context.Context
		arg2 string
	}{arg1, arg2})
	stub := fake.GetEmailConfirmationCodeStub
	fakeReturns := fake.getEmailConfirmationCodeReturns
	fake.recordInvocation("GetEmailConfirmationCode", []interface{}{arg1, arg2})
	fake.getEmailConfirmationCodeMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeUserService) GetEmailConfirmationCodeCallCount() int {
	fake.getEmailConfirmationCodeMutex.RLock()
	defer fake.getEmailConfirmationCodeMutex.RUnlock()
	return len(fake.getEmailConfirmationCodeArgsForCall)
}

func (fake *FakeUserService) GetEmailConfirmationCodeCalls(stub func(context.Context, string) error) {
	fake.getEmailConfirmationCodeMutex.Lock()
	defer fake.getEmailConfirmationCodeMutex.Unlock()
	fake.GetEmailConfirmationCodeStub = stub
}

func (fake *FakeUserService) GetEmailConfirmationCodeArgsForCall(i int) (context.Context, string) {
	fake.getEmailConfirmationCodeMutex.RLock()
	defer fake.getEmailConfirmationCodeMutex.RUnlock()
	argsForCall := fake.getEmailConfirmationCodeArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeUserService) GetEmailConfirmationCodeReturns(result1 error) {
	fake.getEmailConfirmationCodeMutex.Lock()
	defer fake.getEmailConfirmationCodeMutex.Unlock()
	fake.GetEmailConfirmationCodeStub = nil
	fake.getEmailConfirmationCodeReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeUserService) GetEmailConfirmationCodeReturnsOnCall(i int, result1 error) {
	fake.getEmailConfirmationCodeMutex.Lock()
	defer fake.getEmailConfirmationCodeMutex.Unlock()
	fake.GetEmailConfirmationCodeStub = nil
	if fake.getEmailConfirmationCodeReturnsOnCall == nil {
		fake.getEmailConfirmationCodeReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.getEmailConfirmationCodeReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeUserService) GetUserById(arg1 context.Context, arg2 string) (internal.User, error) {
	fake.getUserByIdMutex.Lock()
	ret, specificReturn := fake.getUserByIdReturnsOnCall[len(fake.getUserByIdArgsForCall)]
	fake.getUserByIdArgsForCall = append(fake.getUserByIdArgsForCall, struct {
		arg1 context.Context
		arg2 string
	}{arg1, arg2})
	stub := fake.GetUserByIdStub
	fakeReturns := fake.getUserByIdReturns
	fake.recordInvocation("GetUserById", []interface{}{arg1, arg2})
	fake.getUserByIdMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeUserService) GetUserByIdCallCount() int {
	fake.getUserByIdMutex.RLock()
	defer fake.getUserByIdMutex.RUnlock()
	return len(fake.getUserByIdArgsForCall)
}

func (fake *FakeUserService) GetUserByIdCalls(stub func(context.Context, string) (internal.User, error)) {
	fake.getUserByIdMutex.Lock()
	defer fake.getUserByIdMutex.Unlock()
	fake.GetUserByIdStub = stub
}

func (fake *FakeUserService) GetUserByIdArgsForCall(i int) (context.Context, string) {
	fake.getUserByIdMutex.RLock()
	defer fake.getUserByIdMutex.RUnlock()
	argsForCall := fake.getUserByIdArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeUserService) GetUserByIdReturns(result1 internal.User, result2 error) {
	fake.getUserByIdMutex.Lock()
	defer fake.getUserByIdMutex.Unlock()
	fake.GetUserByIdStub = nil
	fake.getUserByIdReturns = struct {
		result1 internal.User
		result2 error
	}{result1, result2}
}

func (fake *FakeUserService) GetUserByIdReturnsOnCall(i int, result1 internal.User, result2 error) {
	fake.getUserByIdMutex.Lock()
	defer fake.getUserByIdMutex.Unlock()
	fake.GetUserByIdStub = nil
	if fake.getUserByIdReturnsOnCall == nil {
		fake.getUserByIdReturnsOnCall = make(map[int]struct {
			result1 internal.User
			result2 error
		})
	}
	fake.getUserByIdReturnsOnCall[i] = struct {
		result1 internal.User
		result2 error
	}{result1, result2}
}

func (fake *FakeUserService) Login(arg1 context.Context, arg2 string, arg3 string) (string, error) {
	fake.loginMutex.Lock()
	ret, specificReturn := fake.loginReturnsOnCall[len(fake.loginArgsForCall)]
	fake.loginArgsForCall = append(fake.loginArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 string
	}{arg1, arg2, arg3})
	stub := fake.LoginStub
	fakeReturns := fake.loginReturns
	fake.recordInvocation("Login", []interface{}{arg1, arg2, arg3})
	fake.loginMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeUserService) LoginCallCount() int {
	fake.loginMutex.RLock()
	defer fake.loginMutex.RUnlock()
	return len(fake.loginArgsForCall)
}

func (fake *FakeUserService) LoginCalls(stub func(context.Context, string, string) (string, error)) {
	fake.loginMutex.Lock()
	defer fake.loginMutex.Unlock()
	fake.LoginStub = stub
}

func (fake *FakeUserService) LoginArgsForCall(i int) (context.Context, string, string) {
	fake.loginMutex.RLock()
	defer fake.loginMutex.RUnlock()
	argsForCall := fake.loginArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeUserService) LoginReturns(result1 string, result2 error) {
	fake.loginMutex.Lock()
	defer fake.loginMutex.Unlock()
	fake.LoginStub = nil
	fake.loginReturns = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeUserService) LoginReturnsOnCall(i int, result1 string, result2 error) {
	fake.loginMutex.Lock()
	defer fake.loginMutex.Unlock()
	fake.LoginStub = nil
	if fake.loginReturnsOnCall == nil {
		fake.loginReturnsOnCall = make(map[int]struct {
			result1 string
			result2 error
		})
	}
	fake.loginReturnsOnCall[i] = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeUserService) Search(arg1 context.Context, arg2 string) (*internal.User, error) {
	fake.searchMutex.Lock()
	ret, specificReturn := fake.searchReturnsOnCall[len(fake.searchArgsForCall)]
	fake.searchArgsForCall = append(fake.searchArgsForCall, struct {
		arg1 context.Context
		arg2 string
	}{arg1, arg2})
	stub := fake.SearchStub
	fakeReturns := fake.searchReturns
	fake.recordInvocation("Search", []interface{}{arg1, arg2})
	fake.searchMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeUserService) SearchCallCount() int {
	fake.searchMutex.RLock()
	defer fake.searchMutex.RUnlock()
	return len(fake.searchArgsForCall)
}

func (fake *FakeUserService) SearchCalls(stub func(context.Context, string) (*internal.User, error)) {
	fake.searchMutex.Lock()
	defer fake.searchMutex.Unlock()
	fake.SearchStub = stub
}

func (fake *FakeUserService) SearchArgsForCall(i int) (context.Context, string) {
	fake.searchMutex.RLock()
	defer fake.searchMutex.RUnlock()
	argsForCall := fake.searchArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeUserService) SearchReturns(result1 *internal.User, result2 error) {
	fake.searchMutex.Lock()
	defer fake.searchMutex.Unlock()
	fake.SearchStub = nil
	fake.searchReturns = struct {
		result1 *internal.User
		result2 error
	}{result1, result2}
}

func (fake *FakeUserService) SearchReturnsOnCall(i int, result1 *internal.User, result2 error) {
	fake.searchMutex.Lock()
	defer fake.searchMutex.Unlock()
	fake.SearchStub = nil
	if fake.searchReturnsOnCall == nil {
		fake.searchReturnsOnCall = make(map[int]struct {
			result1 *internal.User
			result2 error
		})
	}
	fake.searchReturnsOnCall[i] = struct {
		result1 *internal.User
		result2 error
	}{result1, result2}
}

func (fake *FakeUserService) SignUp(arg1 context.Context, arg2 internal.UserCreateParams) (internal.User, string, error) {
	fake.signUpMutex.Lock()
	ret, specificReturn := fake.signUpReturnsOnCall[len(fake.signUpArgsForCall)]
	fake.signUpArgsForCall = append(fake.signUpArgsForCall, struct {
		arg1 context.Context
		arg2 internal.UserCreateParams
	}{arg1, arg2})
	stub := fake.SignUpStub
	fakeReturns := fake.signUpReturns
	fake.recordInvocation("SignUp", []interface{}{arg1, arg2})
	fake.signUpMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakeUserService) SignUpCallCount() int {
	fake.signUpMutex.RLock()
	defer fake.signUpMutex.RUnlock()
	return len(fake.signUpArgsForCall)
}

func (fake *FakeUserService) SignUpCalls(stub func(context.Context, internal.UserCreateParams) (internal.User, string, error)) {
	fake.signUpMutex.Lock()
	defer fake.signUpMutex.Unlock()
	fake.SignUpStub = stub
}

func (fake *FakeUserService) SignUpArgsForCall(i int) (context.Context, internal.UserCreateParams) {
	fake.signUpMutex.RLock()
	defer fake.signUpMutex.RUnlock()
	argsForCall := fake.signUpArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeUserService) SignUpReturns(result1 internal.User, result2 string, result3 error) {
	fake.signUpMutex.Lock()
	defer fake.signUpMutex.Unlock()
	fake.SignUpStub = nil
	fake.signUpReturns = struct {
		result1 internal.User
		result2 string
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeUserService) SignUpReturnsOnCall(i int, result1 internal.User, result2 string, result3 error) {
	fake.signUpMutex.Lock()
	defer fake.signUpMutex.Unlock()
	fake.SignUpStub = nil
	if fake.signUpReturnsOnCall == nil {
		fake.signUpReturnsOnCall = make(map[int]struct {
			result1 internal.User
			result2 string
			result3 error
		})
	}
	fake.signUpReturnsOnCall[i] = struct {
		result1 internal.User
		result2 string
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeUserService) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.confirmSignUpMutex.RLock()
	defer fake.confirmSignUpMutex.RUnlock()
	fake.getEmailConfirmationCodeMutex.RLock()
	defer fake.getEmailConfirmationCodeMutex.RUnlock()
	fake.getUserByIdMutex.RLock()
	defer fake.getUserByIdMutex.RUnlock()
	fake.loginMutex.RLock()
	defer fake.loginMutex.RUnlock()
	fake.searchMutex.RLock()
	defer fake.searchMutex.RUnlock()
	fake.signUpMutex.RLock()
	defer fake.signUpMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeUserService) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ rest.UserService = new(FakeUserService)
